## 进程一些概念

### 进程的用户和组标识符（凭证）

每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)，如下所示：

- 真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。
- 有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，
  进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效 ID 实为一种机制，可使进程具有其他用户或组的权限。
- 补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录 shell 则从系统组文件中获取其补充组 ID。

### 特权进程

特权进程是指有效用户 ID 为 0（超级用户）的进程。通常由内核所施加的权限限制对此类进程无效。

“无特权”（或非特权）进程是指由其他用户运行的进程。此类进程的有效用户 ID 为非 0 值，且必须遵守由内核所强加的权限规则。

由特权进程创建的进程，也可以是特权进程。例如，一个由 root（超级用户）发起的登录 shell。成为特权进程的另一方法是利用 set-user-ID 机制，该机制允许某进程的有效用户 ID 等同于该进程所执行程序文件的用户 ID。

### 能力（Capabilities）

Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。

每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。
赋予某进程部分能力，使得其既能够执行某些特权级操作，又防止其执行其他特权级操作。能力的命名以 CAP\_为前缀，例如， CAP_KILL。

### init 进程

系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 frok()）“亲自”创建，就是由其后代进程创建。 init 进程的进程号总为 1，且总是以超级用户权限运行。谁（哪怕是超级用户）都不能“杀死” init 进程，只有关闭系统才能终止该进程。 init 的主要任务是创建并监控系统运行所需的一系列进程。

### 环境列表

每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。这份列表的每一元素都由一个名称及其相关值组成。由 fork()创建的新进程，会继承父进程的环境副本。这也为父子进程间通信提供了一种机制。当进程调用 exec()替换当前正在运行的程序时，新程序要么继承老程序的环境，要么在 exec()调用的参数中指定新环境并加以接收。

在绝大多数 shell 中，可使用 export 命令来创建环境变量（C shell 使用 setenv 命令），如下所示：

```
$ export MYVAR='hello world'
```

### 资源限制

每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源设定一个上限。此类资源限制的每一项均有两个相关值：软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（ hard limit）软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。

由 fork()创建的新进程，会继承其父进程对资源限制的设置。

使用 ulimit 命令（在 C shell 中为 limit）可调整 shell 的资源限制。 shell 为执行命令所创建的子进程会继承上述资源设置。

### 进程与时间

- 真实时间：进程的生命周期时间
- 进程时间：也称为 CPU 时间，指进程自启动起来，所占用 cpu 时间总量
  - 系统 CPU 时间：内核模式中，执行代码花费的时间，比如执行系统调用
  - 用户 CPU 时间：用户模式中，执行代码花费的时间，比如常规代码运行

time 命令会显示出真实时间、系统 CPU 时间，以及执行管道中的多个进程花费的用户 CPU 时间。

### 实时性

为支持实时性应用， POSIX.1b 定义了多个 POSIX.1 扩展，其中包括异步 I/O、共享内存、内存映射文件、内存锁定、实时性时钟和定时器、备选调度策略、实时性信号、消息队列、以及信号量等
